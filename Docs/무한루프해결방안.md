# JavaScript 코드 에디터 - 무한 루프 해결 방안

## 현재 문제점

`script.js`에서 `new Function()`을 사용해 사용자 코드를 **메인 스레드에서 동기 실행**하고 있습니다.
무한 루프가 실행되면 브라우저 UI가 완전히 멈추고, 탭을 강제 종료해야 합니다.

```javascript
// 현재 코드 (script.js:116)
let result = new Function(executionCode)();
```

---

## 해결 방안 비교

| 방안 | 난이도 | 안정성 | 사용자 경험 | 추천도 |
|------|--------|--------|-------------|--------|
| 1. Web Worker | 중 | 높음 | 좋음 | ⭐⭐⭐⭐⭐ |
| 2. iframe 샌드박스 | 중 | 높음 | 좋음 | ⭐⭐⭐⭐ |
| 3. 코드 변환 (Instrumentation) | 상 | 중간 | 보통 | ⭐⭐⭐ |
| 4. setTimeout 청킹 | 하 | 낮음 | 나쁨 | ⭐⭐ |

---

## 방안 1: Web Worker (권장)

### 개념
별도의 스레드에서 코드를 실행하고, 타임아웃 시 Worker를 종료합니다.

### 장점
- 메인 스레드가 절대 블로킹되지 않음
- UI가 항상 반응함
- `worker.terminate()`로 즉시 중단 가능

### 단점
- DOM 접근 불가 (`document`, `window` 사용 불가)
- `console.log`를 메인 스레드로 전달해야 함

### 구현 예시

**worker.js** (새 파일 생성)
```javascript
self.onmessage = function(e) {
    const { code, isStrict } = e.data;
    const logs = [];

    // console.log 캡처
    const originalLog = console.log;
    console.log = (...args) => {
        logs.push(args.map(arg =>
            typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
        ).join(' '));
    };

    try {
        const strictPragma = isStrict ? "'use strict';\n" : "";
        const result = new Function(strictPragma + code)();
        self.postMessage({
            success: true,
            result: result,
            logs: logs
        });
    } catch (error) {
        self.postMessage({
            success: false,
            error: error.message,
            logs: logs
        });
    }
};
```

**script.js 수정**
```javascript
function executeWithTimeout(code, isStrict, timeout = 5000) {
    return new Promise((resolve, reject) => {
        const worker = new Worker('worker.js');

        const timer = setTimeout(() => {
            worker.terminate();
            reject(new Error('실행 시간 초과 (무한 루프 의심)'));
        }, timeout);

        worker.onmessage = (e) => {
            clearTimeout(timer);
            worker.terminate();
            resolve(e.data);
        };

        worker.onerror = (e) => {
            clearTimeout(timer);
            worker.terminate();
            reject(new Error(e.message));
        };

        worker.postMessage({ code, isStrict });
    });
}

// 사용
$submitButton.addEventListener("click", async (e) => {
    e.preventDefault();
    const code = editor.getValue();

    try {
        const result = await executeWithTimeout(code, isStrict, 5000);
        // 결과 처리...
    } catch (err) {
        $returnView.textContent = err.message;
    }
});
```

---

## 방안 2: iframe 샌드박스

### 개념
격리된 iframe에서 코드를 실행하고, 타임아웃 시 iframe을 제거합니다.

### 장점
- DOM API 일부 사용 가능
- 완전히 격리된 환경
- 보안성 높음

### 단점
- iframe 생성/제거 오버헤드
- postMessage 통신 필요

### 구현 예시

```javascript
function executeInIframe(code, timeout = 5000) {
    return new Promise((resolve, reject) => {
        const iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        iframe.sandbox = 'allow-scripts';
        document.body.appendChild(iframe);

        const timer = setTimeout(() => {
            document.body.removeChild(iframe);
            reject(new Error('실행 시간 초과 (무한 루프 의심)'));
        }, timeout);

        window.addEventListener('message', function handler(e) {
            if (e.source === iframe.contentWindow) {
                clearTimeout(timer);
                window.removeEventListener('message', handler);
                document.body.removeChild(iframe);

                if (e.data.success) {
                    resolve(e.data);
                } else {
                    reject(new Error(e.data.error));
                }
            }
        });

        const script = `
            <script>
                const logs = [];
                console.log = (...args) => logs.push(args.join(' '));
                try {
                    const result = (function() { ${code} })();
                    parent.postMessage({ success: true, result, logs }, '*');
                } catch(e) {
                    parent.postMessage({ success: false, error: e.message, logs }, '*');
                }
            </script>
        `;
        iframe.srcdoc = script;
    });
}
```

---

## 방안 3: 코드 변환 (Instrumentation)

### 개념
실행 전에 코드를 파싱하여 모든 루프에 카운터/타임아웃 체크 코드를 삽입합니다.

### 장점
- 외부 리소스 불필요
- 정확한 루프 감지

### 단점
- 구현 복잡도 높음
- 파서 라이브러리 필요 (acorn, babel 등)
- 일부 코드 패턴에서 오작동 가능

### 구현 예시 (간단 버전)

```javascript
function instrumentCode(code) {
    const maxIterations = 100000;
    let counter = 0;

    // 간단한 정규식 변환 (완벽하지 않음)
    const instrumented = code
        .replace(/while\s*\(/g, `while (++__loopCounter < ${maxIterations} && (`)
        .replace(/for\s*\(/g, (match) => {
            // for 문은 더 복잡한 처리 필요
            return match;
        });

    return `
        let __loopCounter = 0;
        ${instrumented}
        if (__loopCounter >= ${maxIterations}) {
            throw new Error('최대 반복 횟수 초과');
        }
    `;
}
```

### 라이브러리 활용 (권장)

```javascript
// Babel 또는 acorn 사용
import * as acorn from 'acorn';
import * as walk from 'acorn-walk';

function instrumentWithAST(code) {
    const ast = acorn.parse(code, { ecmaVersion: 2020 });
    // AST를 순회하며 WhileStatement, ForStatement에 체크 코드 삽입
    // ...
}
```

---

## 방안 4: setTimeout 청킹 (비권장)

### 개념
코드를 분석하여 루프를 비동기 청크로 변환합니다.

### 장점
- Worker 없이 구현 가능

### 단점
- 구현 매우 복잡
- 동기 코드의 의미가 변경됨
- 실용성 낮음

---

## 권장 구현 순서

### 최소 구현 (빠른 적용)
1. **Web Worker 방안** 적용
2. 타임아웃 5초 설정
3. "실행 중..." 로딩 표시 추가
4. "중지" 버튼 추가

### 추가 개선
1. 타임아웃 시간을 사용자가 설정 가능하게
2. 실행 중 프로그레스 표시
3. 메모리 사용량 모니터링

---

## 참고: 실행 중지 버튼 추가

```html
<button id="stop-btn" style="display:none;">실행 중지</button>
```

```javascript
let currentWorker = null;

$stopBtn.addEventListener('click', () => {
    if (currentWorker) {
        currentWorker.terminate();
        currentWorker = null;
        $returnView.textContent = '사용자가 실행을 중지했습니다.';
    }
});
```

---

## 결론

**Web Worker 방안**이 가장 안정적이고 구현 난이도도 적절합니다.

1. 메인 스레드 블로킹 완전 방지
2. 타임아웃으로 무한 루프 감지
3. 사용자가 직접 중지 가능
4. console.log 캡처 가능

DOM 조작이 필요한 코드를 지원해야 한다면 **iframe 샌드박스**를 고려하세요.
